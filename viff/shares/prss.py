# -*- coding: utf-8 -*-
#
# Copyright 2007, 2008, 2009 VIFF Development Team.
#
# This file is part of VIFF, the Virtual Ideal Functionality Framework.
#
# VIFF is free software: you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License (LGPL) as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# VIFF is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
# or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General
# Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with VIFF. If not, see <http://www.gnu.org/licenses/>.

u"""Methods for pseudo-random secret sharing. Normal Shamir sharing
(see the :mod:`viff.shamir` module) requires secure channels between
the players for distributing shares. With pseudo-random secret sharing
one can share a secret using a single broadcast instead.

PRSS relies on each player having access to a set of previously
distributed pseudo-random functions (PRFs) --- or rather the seeds for
such functions. In VIFF, such seeds are generated by
:func:`~viff.config.generate_configs`. The
:meth:`~viff.config.Player.prfs` and
:meth:`~viff.config.Player.dealer_prfs` methods give access to the
PRFs.

In this module the function :func:`prss` is used to calculate shares
for a pseudo-random number. The :func:`generate_subsets` function is a
general utility for generating subsets of a specific size.

The code is based on the paper "Share Conversion, Pseudorandom
Secret-Sharing and Applications to Secure Computation" by Ronald
Cramer, Ivan Damg√•rd, and Yuval Ishai in Proc. of TCC 2005, LNCS 3378.
`Download <http://www.cs.technion.ac.il/~yuvali/pubs/CDI05.ps>`__.
"""

from viff.math.field import GF256
from viff.shares import shamir
from viff.utils.util import fake


def random_replicated_sharing(j, prfs, key):
    """Return a replicated sharing of a random number.

    The shares are for player *j* based on the pseudo-random functions
    given in *prfs* (a mapping from subsets of players to :class:`PRF`
    instances). The *key* is used when evaluating the PRFs. The result
    is a list of ``(subset, share)`` pairs.
    """
    # The PRFs contain the subsets we need, plus some extra in the
    # case of dealer_keys. That is why we have to check that j is in
    # the subset before using it.
    return [(s, prf(key)) for (s, prf) in prfs.iteritems() if j in s]


#: Cache the coefficients used to construct the share. They depend on the field,
#: the player concerned, the total number of players, and the subset.
_f_in_j_cache = {}


def convert_replicated_shamir(num_players, player_id, field, rep_shares):
    """Convert a set of replicated shares to a Shamir share.

    The conversion is done for player *j* (out of *n*) and will be
    done over *field*.
    """
    result = 0
    all = frozenset(range(1, num_players + 1))
    for subset, share in rep_shares:
        try:
            f_in_j = _f_in_j_cache[(field, num_players, player_id, subset)]
        except KeyError:
            points = [(field(x), 0) for x in all - subset]
            points.append((0, 1))
            f_in_j = shamir.recombine(points, player_id)
            _f_in_j_cache[(field, num_players, player_id, subset)] = f_in_j
        result += share * f_in_j
    return result


@fake(lambda n, j, field, prfs, key: field(7))
def prss(num_players, player_id, field, prfs, key):
    """Return a pseudo-random secret share for a random number.

    The share is for player *j* based on the pseudo-random functions
    given in *prfs* (a mapping from subsets of players to :class:`PRF`
    instances). The *key* is used when evaluating the PRFs.

    An example with (n,t) = (3,1) and a modulus of 31:

    >>> from viff.math.field import GF
    >>> from viff.shares.prf import PRF
    >>> Zp = GF(31)
    >>> prfs = {frozenset([1,2]): PRF("a", 31),
    ...         frozenset([1,3]): PRF("b", 31),
    ...         frozenset([2,3]): PRF("c", 31)}
    >>> prss(3, 1, Zp, prfs, "key")
    {22}
    >>> prss(3, 2, Zp, prfs, "key")
    {20}
    >>> prss(3, 3, Zp, prfs, "key")
    {18}

    We see that the sharing is consistent because each subset of two
    players will recombine their shares to ``{24}``.
    """
    rep_shares = random_replicated_sharing(player_id, prfs, key)
    return convert_replicated_shamir(num_players, player_id, field, rep_shares)


def prss_multi(n, j, field, prfs, key, modulus, quantity):
    """Does the same as :meth:`prss`, but multiple times in order to
    call the PRFs less frequently.
    """
    prf_results = random_replicated_sharing(j, prfs, key)
    rep_shares_list = [[] for i in range(quantity)]
    for subset, result in prf_results:
        for i in range(quantity):
            rep_shares_list[i].append((subset, result % modulus))
            result /= modulus
    return [convert_replicated_shamir(n, j, field, rep_shares)
            for rep_shares in rep_shares_list]


@fake(lambda n, j, field, prfs, key: (field(7), GF256(1)))
def prss_lsb(n, j, field, prfs, key):
    """Share a pseudo-random number and its least significant bit.

    The random number is shared over *field* and its least significant
    bit is shared over :class:`viff.field.GF256`. It is important the
    *prfs* generate numbers much less than the size of *field* -- we
    must be able to do an addition for each PRF without overflow in
    *field*.

    >>> from viff.math.field import GF
    >>> from viff.shares.prf import PRF
    >>> Zp = GF(23)
    >>> prfs = {frozenset([1,2]): PRF("a", 7),
    ...         frozenset([1,3]): PRF("b", 7),
    ...         frozenset([2,3]): PRF("c", 7)}
    >>> prss_lsb(3, 1, Zp, prfs, "key")
    ({0}, [140])
    >>> prss_lsb(3, 2, Zp, prfs, "key")
    ({15}, [3])
    >>> prss_lsb(3, 3, Zp, prfs, "key")
    ({7}, [143])

    We see that the random value must be ``{8}`` and so the least
    significant bit must be ``[0]``. We can check this by recombining
    any two of the three shares:

    >>> from viff.shares.shamir import recombine
    >>> recombine([(GF256(1), GF256(140)), (GF256(2), GF256(3))])
    [0]
    >>> recombine([(GF256(2), GF256(3)),   (GF256(3), GF256(143))])
    [0]
    >>> recombine([(GF256(3), GF256(143)), (GF256(1), GF256(140))])
    [0]
    """
    rep_shares = random_replicated_sharing(j, prfs, key)
    lsb_shares = [(s, r & 1) for (s, r) in rep_shares]
    return (convert_replicated_shamir(n, j, field, rep_shares),
            convert_replicated_shamir(n, j, GF256, lsb_shares))


@fake(lambda n, t, j, field, prfs, key, quantity: [field(0)] * quantity)
def prss_zero(n, t, j, field, prfs, key, quantity):
    """Return *quantity* pseudo-random secret zero-sharings of degree 2t.

    >>> from viff.math.field import GF
    >>> from viff.shares.prf import PRF
    >>> Zp = GF(23)
    >>> prfs = {frozenset([1,2]): PRF("a", 7),
    ...         frozenset([1,3]): PRF("b", 7),
    ...         frozenset([2,3]): PRF("c", 7)}
    >>> prss_zero(3, 1, 1, Zp, prfs, "key", 1)
    [{16}]
    >>> prss_zero(3, 1, 2, Zp, prfs, "key", 1)
    [{13}]
    >>> prss_zero(3, 1, 3, Zp, prfs, "key", 1)
    [{14}]

    If we recombine 2t + 1 = 3 shares we can verify that this is
    indeed a zero-sharing:

    >>> from viff.shares.shamir import recombine
    >>> recombine([(Zp(1), Zp(4)), (Zp(2), Zp(0)), (Zp(3), Zp(11))])
    {0}
    """
    # We start by generating t random numbers for each subset. This is
    # very similar to calling random_replicated_sharing t times, but
    # by doing it like this we immediatedly get the nesting we want.
    rep_shares = [(s, [(i + 1, prf((key, i))) for i in range(t)])
                  for (s, prf) in prfs.iteritems() if j in s]

    # We then proceed with the zero-sharing. The first part is like in
    # a normal PRSS.
    result = [0] * quantity
    all = frozenset(range(1, n + 1))
    modulus = field.modulus

    # This is needed for correct exponentiation.
    j = field(j)

    for subset, shares in rep_shares:
        try:
            f_in_j = _f_in_j_cache[(field, n, j, subset)]
        except KeyError:
            points = [(field(x), 0) for x in all - subset]
            points.append((0, 1))
            f_in_j = shamir.recombine(points, j)
            _f_in_j_cache[(field, n, j, subset)] = f_in_j

        # Unlike a normal PRSS we have an inner sum where we use a
        # degree 2t polynomial g_i which we choose as
        #
        #   g_i(x) = f(x) * x**j
        #
        # since we already have the degree t polynomial f at hand. The
        # g_i are all linearly independent as required by the protocol
        # and can thus be used for the zero-sharing.
        for i, packed_share in shares:
            g_i_in_j = f_in_j * j ** i

            for k in range(quantity):
                result[k] += (packed_share % modulus) * g_i_in_j
                packed_share /= modulus

    return result


def generate_subsets(orig_set, size):
    """Generates the set of all subsets of a specific size.

    >>> generate_subsets(frozenset('abc'), 2)
    frozenset([frozenset(['c', 'b']), frozenset(['a', 'c']), frozenset(['a', 'b'])])

    Generating subsets larger than the initial set return the empty
    set:

    >>> generate_subsets(frozenset('a'), 2)
    frozenset([])
    """
    if len(orig_set) > size:
        result = set()
        for element in orig_set:
            result.update(generate_subsets(orig_set - {element}, size))
        return frozenset(result)
    elif len(orig_set) == size:
        return frozenset([orig_set])
    else:
        return frozenset()


if __name__ == "__main__":
    import doctest  # pragma NO COVER

    doctest.testmod()  # pragma NO COVER
